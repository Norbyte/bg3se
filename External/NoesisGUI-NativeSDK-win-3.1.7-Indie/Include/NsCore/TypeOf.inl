////////////////////////////////////////////////////////////////////////////////////////////////////
// NoesisGUI - http://www.noesisengine.com
// Copyright (c) 2013 Noesis Technologies S.L. All Rights Reserved.
////////////////////////////////////////////////////////////////////////////////////////////////////


#include <NsCore/Noesis.h>
#include <NsCore/KernelApi.h>
#include <NsCore/CompilerTools.h>
#include <NsCore/TypePointer.h>
#include <NsCore/Symbol.h>
#include <NsCore/Reflection.h>

#include <stdio.h>


namespace Noesis
{

class TypeEnum;
class TypeClass;
template<class T> struct TypeEnumFiller;

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for void
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<void>
{
    typedef Type ReturnType;
    static const ReturnType* Get() { return nullptr; }
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for classes and enums
////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> struct TypeOfHelper
{
    struct Class
    {
        typedef TypeClass ReturnType;
        static const ReturnType* Get() { return T::StaticGetClassType((TypeTag<T>*)nullptr); }
    };

    struct Enum
    {
        typedef TypeEnum ReturnType;
        static const ReturnType* Get() { return TypeEnumFiller<T>::GetType(); }
    };

    typedef If<IsEnum<T>::Result, Enum, Class> ClassEnumCheck;

public:
    typedef typename ClassEnumCheck::ReturnType ReturnType;

    static const ReturnType* Get()
    {
        return ClassEnumCheck::Get();
    }
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// Helper to easily create new TypeOfHelper specializations
////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, class TypeT>
struct TypeOfHelperBase
{
    typedef TypeT ReturnType;

    NS_NO_INLINE static const TypeT* Get()
    {
        static const TypeT* type;

        if (NS_UNLIKELY(type == 0))
        {
            type = (const TypeT*)(Reflection::RegisterType(TypeOfHelper<T>::GetName(), Create,
                TypeOfHelper<T>::Fill));
        }

        return type;
    }

    static Type* Create(Symbol name) { return new TypeT(name); }
    static void Fill(Type*) {}
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for bool
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<bool>: public TypeOfHelperBase<bool, TypeMeta>
{
    static const char* GetName() { return "Bool"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for int8_t
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<int8_t>: public TypeOfHelperBase<int8_t, TypeMeta>
{
    static const char* GetName() { return "Int8"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for int16_t
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<int16_t>: public TypeOfHelperBase<int16_t, TypeMeta>
{
    static const char* GetName() { return "Int16"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for int32_t
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<int32_t>: public TypeOfHelperBase<int32_t, TypeMeta>
{
    static const char* GetName() { return "Int32"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for int64_t
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<int64_t>: public TypeOfHelperBase<int64_t, TypeMeta>
{
    static const char* GetName() { return "Int64"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for uint8_t
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<uint8_t>: public TypeOfHelperBase<uint8_t, TypeMeta>
{
    static const char* GetName() { return "UInt8"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for uint16_t
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<uint16_t>: public TypeOfHelperBase<uint16_t, TypeMeta>
{
    static const char* GetName() { return "UInt16"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for uint32_t
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<uint32_t>: public TypeOfHelperBase<uint32_t, TypeMeta>
{
    static const char* GetName() { return "UInt32"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for uint64_t
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<uint64_t>: public TypeOfHelperBase<uint64_t, TypeMeta>
{
    static const char* GetName() { return "UInt64"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for float
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<float>: public TypeOfHelperBase<float, TypeMeta>
{
    static const char* GetName() { return "Single"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for double
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<double>: public TypeOfHelperBase<double, TypeMeta>
{
    static const char* GetName() { return "Double"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for char
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<char>: public TypeOfHelperBase<char, TypeMeta>
{
    static const char* GetName() { return "Char"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for String
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<String>: public TypeOfHelperBase<String, TypeMeta>
{
    static const char* GetName() { return "String"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for Symbol
////////////////////////////////////////////////////////////////////////////////////////////////////
template<> struct TypeOfHelper<Symbol>: public TypeOfHelperBase<Symbol, TypeMeta>
{
    static const char* GetName() { return "Symbol"; };
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for references (T&)
////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> struct TypeOfHelper<T&>: public TypeOfHelperBase<T&, TypeReference>
{
    static Symbol GetName()
    {
        char str[256];
        snprintf(str, 256, "%s&", TypeOf<T>()->GetName());
        return Symbol(str);
    }

    static void Fill(Type* type)
    {
        TypeReference* typeReference = (TypeReference*)(type);
        typeReference->SetContentType(TypeOf<T>());
    }
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for const types (const T)
////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> struct TypeOfHelper<const T>: public TypeOfHelperBase<const T, TypeConst>
{
    static Symbol GetName()
    {
        char str[256];
        snprintf(str, 256, "const %s", TypeOf<T>()->GetName());
        return Symbol(str);
    }

    static void Fill(Type* type)
    {
        TypeConst* typeConst = (TypeConst*)(type);
        typeConst->SetContentType(TypeOf<T>());
    }
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for pointers (T*)
////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> struct TypeOfHelper<T*>: public TypeOfHelperBase<T*, TypePointer>
{
    static Symbol GetName()
    {
        char str[256];
        snprintf(str, 256, "%s*", TypeOf<T>()->GetName());
        return Symbol(str);
    }

    static void Fill(Type* type)
    {
        TypePointer* typePointer = (TypePointer*)(type);
        typePointer->SetStaticContentType(TypeOf<T>());
    }
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for Ptr<T>
////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T> struct TypeOfHelper<Ptr<T>>: public TypeOfHelperBase<Ptr<T>, TypePtr>
{
    static Symbol GetName()
    {
        char str[256];
        snprintf(str, 256, "Ptr<%s>", TypeOf<T>()->GetName());
        return Symbol(str);
    }

    static void Fill(Type* type)
    {
        TypePtr* typePtr = (TypePtr*)(type);
        typePtr->SetStaticContentType(TypeOf<T>());
    }
};

////////////////////////////////////////////////////////////////////////////////////////////////////
/// TypeOfHelper for static arrays
////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N> struct TypeOfHelper<T[N]>: public TypeOfHelperBase<T[N], TypeArray>
{
    static Symbol GetName()
    {
        char str[256];
        snprintf(str, 256, "%s[%d]", TypeOf<T>()->GetName(), N);
        return Symbol(str);
    }

    static void Fill(Type* type)
    {
        TypeArray* typeArray = (TypeArray*)(type);
        typeArray->SetElemCount(N);
        typeArray->SetElemSize(sizeof(T));
        typeArray->SetElemType(TypeOf<T>());
    }
};

}
